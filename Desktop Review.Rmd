---
title: "Desktop Review"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
editor_options: 
  chunk_output_type: console
params:
  origin_login_file: Malawi
  cache: FALSE
---

```{r , echo = TRUE, results='hold', message=FALSE, cache=FALSE, warning=FALSE}

library( rlist )
library(knitr)
library(kableExtra)
library(DT)
require(httr)
require(jsonlite)
require(XML)
require(assertthat)
library( lubridate )
library( scales )
library(tidyverse) 


knitr::opts_chunk$set( echo = TRUE ,
                       # knitr.table.format = "html" ,
                       cache = TRUE # TRUE for testing; FALSE for production
                       )

```


```{r, cache = FALSE}

  # functions for fetching metadata

  dhis2 = "../HMIS/DHIS2/"  # Location of base files

  source( paste0( dhis2,
                  'dhis2-data-munging/bootstrap/bootstrap_functions.R' ) )
  
  # folder for storing review data
  folder = paste0( dhis2 ,  params$origin_login_file  , "/" )
    
  if ( !file.exists( folder ) ){
    dir.create( folder ) 
  } 
 
  
  # login shortcut
   login = function(){
       source( paste0( folder, 
                       tolower( params$origin_login_file ) , 
                       "_login")  )
       loginDHIS2( baseurl, username, password)
   }
 

```

<!-- Define the year-month time periods for the review -->

<!-- NB:  What about IDSR with weeks?  -->

```{r date_strings }

 # Function to create string of dates
  date_code = function( years = 2013:2017 , months = 1:12 ){
    period = character()
    
    for (year in years ){
      for (month in seq_along(months)){
        this_period = paste0( ";", 
                         year , 
                         ifelse( month < 10 , paste0("0", month) , month )
        )
        period =  c(period, this_period )
      }
    }
    
    # remove first ;
    period =  paste( period, collapse = "")
    period = substring( period, 2, nchar(period))
    
    return( period )
  }
 
  periods = date_code() # default: 2013-2017
  # periods = date_code( 2017, 1 ) # January 2017 only
  
  # as character vector
  periods.vector = strsplit( periods, ";" , fixed = TRUE )[[1]]

  
```


# Metadata 


```{r all_meta }

  meta_data_file = paste0( folder , params$origin_login_file, 
                           "_metadata.rds" ) 

  if ( !file.exists( meta_data_file) ){
   
    # login in to server
    login()
  
    md = metadataDHIS2( baseurl, 'all' )
    
    # glimpse( md )
    
    write_rds( md, meta_data_file )
    
  } else {
      
       md = read_rds( meta_data_file )
  }

  # re-order alaphabetically to be easier to browse in View
  md = md[order(names(md))]
  
  # Retrieve access data 
  date_metadata = file.info( meta_data_file )$ctime 
  
```

Results shown are for data accessed on `r format(date_metadata, "%d %B %Y") `.  `r params$origin_login_file` is running DHSI2, version `r md$system$version` (rev. `r md$system$rev`, last updated `r md$system$date`).

## Numbers of each attribute

```{r attribute_numbers }

 map_df( md[names(md)], ~length(.x$id) ) %>% t %>% comma %>% 
    kable( align = 'r' )



```

## Organizational Units and levels

```{r}

feature_type = function( coordinate ){
    n = length( gregexpr( '[' , coordinate , fixed = TRUE)[[1]] )
    
    
    if (n==1) return('Point') 
    if (n>1) return('Polygon') 
    return(NA)

}

  # levels
  levels = character()
      for ( i in seq_along( md$organisationUnitLevels$id) ){
    
        levels =  c(levels, paste0("LEVEL-", i) )
      }
      
      levels = paste( levels, collapse = ";")
  
  levels.vector = strsplit( levels, ";" , fixed = TRUE )[[1]]


   ous =  md$organisationUnits %>% 
        select( id, path, name, shortName, coordinates , 
                created, lastUpdated, openingDate, closedDate 
                ) %>%
        mutate( 
          level = map_int( path, 
                               ~length( gregexpr("/", .x, perl = TRUE)[[1]]) 
                               ) ,
          feature = map_chr( coordinates, ~feature_type(.x) )
        )
    

  table_ou_levels =   count( ous, level ) %>%
      # left_join( select( md$organisationUnitLevel, offlineLevels, name) ,
      left_join( select( md$organisationUnitLevel, name, level ) ,
                  # by = c('level'='offlineLevels') ) %>% 
                  by = c('level'='level') ) %>% 
            filter( !grepl( 'Level', name )  ) %>% # removes generic levels ('Level-8')
      select( level, name, n ) 
  
  
  # Add feature types
  ousFeatures = count( ous, level, feature ) %>% 
      spread(  feature, n )
  
  feature_table = left_join( table_ou_levels, 
                            ousFeatures, by = 'level' ) %>%
      mutate( n = comma(n) ) 
    
  kable( feature_table, align = c( 'l', 'l', 'r' ) ) 

```


There, `r sum( map_lgl( md$organisationUnits$attributeValues , ~length(.x) > 0 ) )` have an attribute values assigned to OU.  


## OU Levels

```{r ou_levels}


  # levels
      levels = character()
      for ( i in seq_along( md$organisationUnitLevels$id) ){
    
        levels =  c(levels, paste0("LEVEL-", i) )
      }
      
      levels = paste( levels, collapse = ";")
  
  # import month by month
  levels.vector = strsplit( levels, ";" , fixed = TRUE )[[1]]
  
```

summarise enumerated features by level

NB : stratify by attributes such as private, public--if available

```{r ous_by_level}


 count(ous, nchar( openingDate)>0 ) # all have

 table( year( ymd_hms( ous$openingDate )) ) # but some are recent

  
  
  n_distinct( ous$name )

  p = strsplit( periods , ";" , fixed = TRUE )[[1]]
  p = paste0( p , "01")
  p = ymd( p )
  
  # number of units per level 
   n.level = list()
   for ( i in seq_along( levels.vector ) ){
      
      n = map_int( p, ~ous %>%
                      filter( level %in% i  ) %>%
                      summarise(
                        n = sum( openingDate < .x & 
                                   ifelse( !is.na(closedDate), 
                                           closedDate > .x, TRUE )
                                 ) ) %>% .$n
      )
      n.level[[i]] = n
   }
   
  # combine into df
  ous.n = data_frame(
    level = rep( seq_along( levels.vector ) , each = length(p) ) ,
    period =  rep( periods.vector, length( levels.vector ) ) ,
    n = unlist( n.level )
  ) %>%
    filter( n > 1 ) 
  
  # convert month-Yr to date
  d = ous.n 
  d$date = fast_strptime( as.character(  d$period ) , "%Y%m") 
  
  ggplot( d,  aes(x = date, y = n )) + 
      geom_point() +
      facet_wrap( ~level , scales = 'free' )
  
  ###NB Join wiht ou levels for labels
  
```

NB: not all ou will be assigned to a dataset, and some may be duplicates...
## OU unit groups and group sets ?   

  - private / public
  - elimination / control 
  
NB  confirm whether all units assigned to group

## Categories linked with orgUnits
  
NB  confirm whether all units assigned to category


## Data elements and categories


```{r}
    de = md$dataElements
    
    # Convert category combo from df to list (ends up with id as character)
    de[, 'categoryCombo' ] = as.list( de[, 'categoryCombo' ] )
    
    # dataElement vars
    # names( de )
    display.vars = c('name', 'zeroIsSignificant', 'id', 'lastUpdated',
                                 'categoryCombo' )
    
    mal = grepl( 'malaria' , de$name , ignore.case = TRUE )
    conf = grepl( 'conf' , de$name , ignore.case = TRUE )
    susp = grepl( 'susp' , de$name , ignore.case = TRUE )
    
    mal.conf = de[ mal & conf, display.vars ] %>%
        rename( categoryCombo.id = categoryCombo ) %>%
        mutate( lastUpdated = format( ymd_hms( lastUpdated ), '%b %Y' ) ) %>%
        left_join(  
            select( md$categoryCombos, id, name, categories ) %>%
                        rename(categoryCombo.id = id,
                               categoryCombo = name ,
                               category.id = categories
                        ) , 
                    by = 'categoryCombo.id'
                    ) 
    
    kable( mal.conf, caption = "Confirmed malaria data elements" )
    
    mal.susp = de[ mal & susp, display.vars ] %>%
        rename( categoryCombo.id = categoryCombo ) %>%
        mutate( lastUpdated = format( ymd_hms( lastUpdated ), '%b %Y' ) ) %>%
        left_join(  
            select( md$categoryCombos, id, name, categories ) %>%
                        rename(categoryCombo.id = id,
                               categoryCombo = name ,
                               category.id = categories
                        ) , 
                    by = 'categoryCombo.id'
                    ) 
    
    kable( mal.susp, caption = 'Suspected malaria data elements' )

```


NB: more description of total vs details for each data element--need to list 

## Datasets

<!-- NB: Define relevent datasets and the malaria data elements assigned to them -->

```{r datasets }

  de = md$dataSets %>% 
    select( id, name, periodType ) %>%
    mutate( categoryCombo = map( md$dataSets$dataSetElements , 'categoryCombo' ) ,
            dataElement = map( md$dataSets$dataSetElements , 'dataElement' ) 
            ) 

   find_dataset_for_element = function( element ){
       de %>%
        mutate( 
            a = map_lgl( dataElement, ~ any( element %in%  .x$id  ) )
            ) %>%
        filter( a ) %>% select( id )
   } 
   
   # test
   # find_dataset_for_element( mal.conf[1, 'id' ] )

   mal.datasets = 
       data_frame( 
           mal.conf.id =  mal.conf[, 'id' ] ,
           mal.conf.name =  mal.conf[, 'name' ] 
               ) %>%
       mutate( dataset.id = map(mal.conf.id,  ~find_dataset_for_element( .x ) ) ) %>%
       unnest %>%
       left_join( select(md$dataSets, id, name ), by = c('id' = 'id') ) %>%
       rename( dataset.id = id , dataset.name = name )
   
   

```

 org units associated with datasets
 
```{r}

  dataset.ous = md$dataSets %>% 
    select( id, name ) %>%
    # filter( name %in% unique( mal.datasets$dataset.name ) ) %>%
    mutate(
        ou = map( id, ~md$dataSets[  md$dataSets$id==.x , ]$organisationUnits ) ,
        num.ou = map_int( ou , ~length( flatten( .x[[1]] ) ) )
    ) %>%
    select( -ou )

    
    

```
 
<!-- Count the org units assigned to each form, which is the basis for the number of expected reports.  If an org unit is not assigned to the dataset, a report is not expected.  -->

```{r dataset_ous , results = 'asis' }

  dataset.ous.n = function( dataset ){
  
    opd.orgs = md$dataSets[ md$dataSets$name %in% mal.datasets ,
                           "organisationUnits"][[1]] %>% 
      mutate( dataset = dataset ) %>%
      right_join( ous , by = "id" ) 
    
    count( opd.orgs, level, dataset ) %>% 
      spread( dataset, n ) %>%
      rename( Unassigned = `<NA>` ) %>%
      kable( "html", caption = dataset ) %>%
      kable_styling(bootstrap_options = c("striped", "hover"))
  }

 # map( mal.datasets, ~dataset.ous.n(.x) ) 
 
 for ( i in seq_along( mal.datasets )){
   print( dataset.ous.n( mal.datasets[i] ) )
 } 
 
  
```

<!-- - Dataset ous by county.... -->


# Data completeness, reporting trends, 



<!-- NB - After getting data, run algorithm for major outliers.  For subsequent charts looking at trends, etc, Replace the outliers so that scale of charts is not distorted to the point where all the true data is not compressed to the bottom of the chart.   -->

## data request 

```{r fetch_data_values }

  data.file = paste0( folder , 
                     params$origin_login_file, 
                     "_datset.rds" )

    if ( file.exists( data.file ) ){
        
          data = readRDS( data.file )
          
    } else {
  
    # data elements:
    de.mal.conf.total = paste( mal.conf$id , collapse  = ";" )
    
    de.mal.susp.total = paste( mal.susp$id , collapse  = ";" )
      
      # login in to server
      login()
      
      # import month by month
      
      data = list()
      data.level = list()
      for ( i in seq_along(periods.vector) ){
    
          print( paste( periods.vector[i] ) )
        
        for ( level in seq_along( levels.vector ) ){
          
          print( levels.vector[level] )
      
        #Assemble the URL ( before starting, double check semicolons for dx dimension )
        url <- paste0( baseurl, "api/analytics/dataValueSet.json?" ,
                      "&dimension=ou:", levels.vector[level] , 
                      "&dimension=pe:" , periods.vector[i] ,
                      "&dimension=dx:" , 
                      #suspected
                      de.mal.susp.total , 
                      
                      # confirmed
                      de.mal.conf.total ,
                      # opd summary
                      # "KNrK5VWTZkx;NLKRV7bYbVy" , # population
                      "&displayProperty=NAME")
      
        # Fetch data
        fetch <- retry( get(url)[[1]] ) # if time-out or other error, will retry 
        
        # if returns a data frame of values (e.g. not 'server error'), then keep
        if ( is.data.frame( fetch ) )  data.level[[level]] = fetch
        
        } 
        
    # combine level data
    data[[i]] = data.table::rbindlist( data.level )
    
        print( paste( scales::comma( nrow( data[[i]] ) ) , "records"  ) )
    
    }
  
      # combine period data
      data = data.table::rbindlist( data )
      
      print( paste( "TOTAL:", scales::comma( nrow( data ) ) , "records"  ) )
    
      # glimpse(data)
      
      saveRDS( data, data.file )
}

```

link with org units 

```{r read_data}

  ous = md$organisationUnits %>% 
    select( id, name, path , featureType, 
            # active , # is not available in all API ?
            openingDate, closedDate ) %>%
    mutate( level = map_dbl( path, 
                           ~length( gregexpr("/", .x, perl = TRUE)[[1]]) 
                           ) 
    )
  
 
```

## Completeness

Completeness by level: 

- crude measure with denom = all orgunits

```{r completeness_crude }
  
  d.ous = inner_join( data, ous, by = c( 'orgUnit' = 'id' ) )
                     
  d.ous.noCat = d.ous %>% 
      group_by( period, level , orgUnit, dataElement ) %>%
      summarise( value = sum( as.integer(value), na.rm = TRUE ) ) %>%
      ungroup %>%
      # level names
      left_join( 
          select( md$organisationUnitLevels, level, name  ), by = 'level' )
    
  s = d.ous.noCat %>%
    rename( dataElement.id = dataElement , 
            level.name = name ) %>%
    group_by( period, level, level.name , dataElement.id ) %>%
    summarise( report = n() )  %>% 
    left_join( count( ous, level ) , by = 'level' ) %>%
    mutate( completeness = report / n ) %>%
    ungroup() %>%
    # data element names 
    left_join( 
        select( md$dataElements, id, name ) %>% 
            rename( dataElement.id = id , dataElement = name ) ,
        by = 'dataElement.id' 
    )
  
  # convert month-Yr to date
  s$date = fast_strptime( as.character(  s$period ) , "%Y%m") 
  
  summary( s$completeness )
  
    ggplot(s,  aes(x = date, y = completeness, 
                   group = level.name , color = level.name )) +
    geom_line() +
    facet_wrap( ~ dataElement, 
                labeller = label_wrap_gen(width = 35, multi_line = TRUE)
                ) +
    labs( title = 'Crude completeness by data element', 
             subtitle =  'denominator is current number of all org units' ,
             caption = params$origin_login_file
             )
  
```

- Summarise org units open each period

Limitation: Because only one openiningDate is recorded, if clinic was closed, then reoppened, it will be reported as if it was always open.  


```{r open_orgs}
 
 
    # convert month-Yr to date
  d = ous.n %>%
      # level names
      left_join( 
          select( md$organisationUnitLevels, level, name  ), by = 'level' )

  d$date = fast_strptime( as.character(  d$period ) , "%Y%m") 
  
  ggplot( d,  aes(x = date, y = n, group = level )) + 
      geom_line() +
      facet_wrap( ~name , scales = 'free' )
  

  
```

<!-- NB:  Use API to save charts as favorites??? -->

<!-- Compare with indicators from other programs--tb, hiv, imm... -->

## Trends

<!-- Compare trends among clinics reporting from begining to all clinics, adjusted for.... change in number clinics?, or partial time-period? -->

## Signal to noise ratio 

<!-- https://www.socialresearchmethods.net/kb/expclass.php -->

<!-- http://www.stat.columbia.edu/~gelman/stuff_for_blog/chap20.pdf -->

<!-- 'Observable effect size'  comparing annual cases by region and significant trends -->

# Field visits

- site selection options
